                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

# 计算机组成原理考点梳理

## 第一单元

### 指令系统

1. **指令**是连接硬件和程序之间的桥梁：

* 对程序来说：最小单元为一条指令
* 对硬件来说：最小功能单元为指令

2. 程序由一个序列的计算机指令组成

3. 指令类型

   <img src="image\coo1.png" alt="image-20220826213545167" style="zoom:67%;" />

4. 指令格式

   <img src="image\coo2.png" alt="image-20220826213814941" style="zoom:67%;" />

5. MIPS指令格式

   <img src="image\coo3.png" alt="image-20220826214030281" style="zoom: 67%;" />
   
   （指令最长时间：lw=2×存储器+2×寄存器+1×ALU）

### 数据表示及检错纠错

1. 数制转换

   * 二进制转十进制

     <img src="image\coo4.png" alt="image-20220826214141584" style="zoom:67%;" />

   * 十进制转二进制

     <img src="image\coo5.png" alt="image-20220826214208054" style="zoom: 67%;" />

2. 原码、反码、补码

   * 零的原码和反码有两个，补码只有一个

     ![image-20220826214239748](image\coo6.png)

   * 补码求真值：
     $$
     N=-b_{n-1}*2^{n-1}+\sum^{n-2}_{i=0}b_i2^i
     $$
     真值求补码：正数……/负数取反（包括符号位）+1

   * 补码加法：连同符号位一起计算

   * 补码移位

     <img src="image\coo7.png" alt="image-20220826214932167" style="zoom:67%;" />

3. 大端和小端

   * 小端：数据高位保存在内存高地址字节中，如

     <img src="image\coo8.png" alt="image-20220826215049437" style="zoom:80%;" />

4. 码距

   * 码距（最小码距）：任意两个合法码之间至少有几个二进制位不相同
   * 码距为1，无检错能力；码距为2，有1位检错能力

   <img src="image\coo12.png" alt="image-20220829173338327" style="zoom:50%;" />

5. 常用检错纠错码：

   * 奇偶校验码：并行数据
   * 汉明码：多位并行数据
   * 循环冗余校验码：串行数据

6. 奇偶校验码：在**k位数据码**之外增加**1位校验位**，总共**k+1位码字**中取值为1的位数总保持**偶数（偶校验）**或**奇数（奇校验）**

7. 汉明码：**k位数据位**形成**r位校验位**

   * $2^r\geq k+r+1$：$2^r$个编码分别表示k个数据位和r个校验位中哪一位出错（加1的这一个1，表示的是全对的情况）；发现并改正一位错
   * $2^{r-1} \geq k+r$：r-1位校验码表示出错位，1位校验码区分1位错还是2位错；发现并改正一位错，发现两位错

8. 汉明码实现方法

   <img src="image\coo9.png" alt="image-20220829172708783" style="zoom:50%;" />

   <img src="image\coo10.png" alt="image-20220829173042740" style="zoom:50%;" />

   <img src="image\coo11.png" alt="image-20220829173245380" style="zoom: 50%;" />

### 算术运算及其电路实现

1. 超前进位加法器

   * $P_i=a_i+b_i$：传播信号（来自前面的数位）
   * $G_i=a_ib_i$：生成信号

2. 布斯算法

   最后一位与附加位（右移前的最后一位，初始为0）：

   * 00/11：直接右移
   * 01：+被乘数再右移
   * 10：-被乘数再右移

   <img src="image\coo13.png" alt="image-20220829174601285" style="zoom:67%;" />

3. 加减交替除法

   例如：X=-0.1011，Y=0.1101，求X/Y

   X的绝对值的补码为001011

   Y的绝对值的补码为001101

   Y的绝对值的相反数的补码为110011

   * 小于零：商0，左移后加回来
   * 大于零：商1，左移后继续减

   <img src="image\coo14.png" alt="image-20220829174946364" style="zoom: 67%;" />

   最后还要判断一下符号，异号则需要求一次反

### 运算器部件组成及设计

### 浮点数表示和运算

1. IEEE浮点数标准754:

   * $X=M_SE_SE_m\ldots E_2E_1M_{-1}M_{-2}\ldots M_{-n}$

   * |          | 符号位数 | 阶码位数       | 尾数位数 | 总位数 |
     | -------- | -------- | -------------- | -------- | ------ |
     | 短浮点数 | 1        | 8（移码127）   | 23       | 32     |
     | 长浮点数 | 1        | 11（移码1023） | 52       | 64     |

   * 移码：$2^{n-1}-1$

   * 特殊值

     | 特殊值                                                 | 阶        | 有效数 |
     | ------------------------------------------------------ | --------- | ------ |
     | $\pm 0$                                                | 0000 0000 | 0      |
     | 非规格化数（$0.M_{-1}M_{-2}\ldots M_{-n}*2^{\cdots}$） | 0000 0000 | 非0    |
     | $\pm \infty$                                           | 1111 1111 | 0      |
     | NaN                                                    | 1111 1111 | 非0    |

2. 浮点数的十进制-二进制转换

   <img src="image\coo15.png" alt="image-20220829185801837" style="zoom: 67%;" />

3. 浮点数加减法

   1. 对阶
   2. 尾数加减
   3. 规格化
   4. 舍入
   5. 溢出判断

      <img src="image\coo16.png" alt="image-20220829191348958" style="zoom: 80%;" />
   

## 第二单元

### 控制器概述 指令和指令系统

1. 指令码的扩展技术（以保留一个编码为例）

   <img src="image\coo17.png" alt="image-20220829191712042" style="zoom: 67%;" />

2. 寻址方式

   | 寻址方式   | 特点                                                         |
   | ---------- | ------------------------------------------------------------ |
   | 立即数寻址 | 直接给出**操作数**                                           |
   | 直接寻址   | 直接给出操作数在**存储器中的地址**                           |
   | 寄存器寻址 | 直接给出操作数所在的**寄存器编号**                           |
   | 寄存器间址 | 给出的**寄存器编号存放**的是操作数在**存储器中的地址**       |
   | 变址寻址   | 变址寄存器中的内容（由Reg指定是哪个寄存器）+变址偏移量（Disp） - 数组；**偏移量不变** |
   | 相对寻址   | 程序计数器PC中的内容+相对偏移量（Disp） - 转移指令；**偏移量可正可负** |
   | 间接寻址   | 给出操作数在**存储器中的地址的地址**（为程序或数据分配存储区） |
   | 基址寻址   | 指令中的地址码+基址寄存器中的内容                            |

### 指令系统举例 控制器设计概述

1. RISC（精简指令系统）和CISC（复杂指令系统）

   * MIPS指令：寄存器型、立即数型、转移型

2. MIPS指令特点

   * 指令长度确定：只需对PC增量即可得到下一条指令的地址（不需要读取完当前指令）
   * 寄存器位置基本固定：指令译码完成前就可以取操作数了

3. 单周期CPU

   <img src="image\coo18.png" alt="image-20220829194708179" style="zoom: 67%;" />

4. 多周期CPU

   <img src="image\coo19.png" alt="image-20220829195022815" style="zoom: 67%;" />

5. 指令流水线CPU

   <img src="image\coo20.png" alt="image-20220829195138043" style="zoom: 67%;" />

### 单周期CPU控制器设计

1. 最长指令：lw

   <img src="image\coo21.png" alt="image-20220829200120325" style="zoom: 67%;" />

2. 其它问题：指令和数据都保存在同一个存储器中，许多部件保存数据的时间过长，无法复用

### 多周期CPU设计

1. 多周期CPU的控制器：控制指令的执行过程，向计算机**各功能部件**提供协调**每一个步骤**所需要的**控制信号**

   <img src="image\coo22.png" alt="image-20220830110853138" style="zoom:50%;" />

2. 控制器分类（指令执行步骤标记线路与控制信号产生线路不同）：

   * 硬连线控制器（组合逻辑控制器）：采用组合逻辑线路，依据指令及其步骤**直接产生控制信号**
     * 程序计数器PC：提供待读出指令在主存储器中的地址
     * 指令寄存器IR：保存从主存储器中读出的指令内容
     * 节拍发生器Timer：给出并维护指令执行步骤的编码
     * 控制信号产生部件：用组合逻辑线路产生各部件所需要的控制信号
     * MIPS控制部件：节拍发生器与控制信号产生线路
   * 微程序控制器：采用存储器电路**把控制信号存储起来**，依据指令执行的步骤读出要用到的信号组合
     * 控制存储器存储每条指令的全部控制信号
     * 微地址访问读出控制信号
     * 下地址逻辑实现执行步骤之间的衔接

3. MIPS机指令

   <img src="image\coo23.png" alt="image-20220830112540658" style="zoom:50%;" />

   <img src="image\coo24.png" alt="image-20220830112713571" style="zoom:50%;" />

### 流水线技术概述

   1. | 流水线分类                         | 范围                                         |
      | ---------------------------------- | -------------------------------------------- |
      | 部件功能级流水线（运算操作流水线） | 运算器中的操作部件（如加法器、乘法器等）之间 |
      | 处理机级流水线（指令流水线）       | 指令之间                                     |
      | 处理机间级流水线（宏流水线）       | 多个计算机之间                               |

   2. 流水线时空图

      <img src="image\coo25.png" alt="image-20220830113328403" style="zoom:50%;" />

   3. 流水线特点

      * 锁存器

        <img src="image\coo26.png" alt="image-20220830113433911" style="zoom:50%;" />

      * 装入时间：第一个任务进入流水线到输出流水线的时间

        排空时间：最后一个任务进入流水线到输出流水线的时间

   4. 性能指标

      * 吞吐率：单位时间执行指令的数量
      * 加速比：与串行执行时速度提高的比率

   5. 流水线的实现原理

      * 每条指令至多5个时钟周期：

        1. 取指令（IF）：PC、IM（指令存储器）
        2. 指令译码（ID/RF）：寄存器组、控制信号生成部件
        3. 执行（EX）：ALU
        4. 存储器访问（MEM）：DM（数据存储器）
        5. 写回（WB）：寄存器组

      * 多周期CPU适合指令流水实现吗？

        * 已分解为多个步骤
        * 但是步骤间的资源冲突比较频繁

      * 划分流水段

        <img src="image\coo27.png" alt="image-20220830133340535" style="zoom: 50%;" />

      * 流水线寄存器：保存中间结果、中间参数、控制信号

        <img src="image\coo28.png" alt="image-20220830133448691" style="zoom: 50%;" />

        各阶段寄存器保存的值
        
        <img src="image\coo29.png" alt="image-20220830180037089" style="zoom:50%;" />
        
      * 流水线的控制：控制信号也流动起来

        <img src="image\coo30.png" alt="image-20220830134445809" style="zoom:50%;" />

   6. 单周期、多周期、流水线比较

      <img src="image\coo31.png" alt="image-20220830134734596" style="zoom: 67%;" />

   7. 流水线冲突

      <img src="image\coo32.png" alt="image-20220830135120442" style="zoom:80%;" />

### 结构冲突与数据冲突

1. 结构冲突：**硬件资源**冲突，为**局部冲突**

2. 结构冲突解决方案：

   1. 暂停流水线
   2. 增加资源：
      1. 双端口存储器（一个存取数据，一个存取指令）
      2. 两个存储器

3. 数据冲突：无法获取正确的源**操作数**，为**局部冲突**

   1. 写后读（RAW）：**本应先写后读**；MIPS流水线只会在访问**寄存器**时发生RAW冲突

   2. 写后写（WAW）：MIPS流水线中只有WB段会写寄存器，因此**不会发生WAW冲突**

   3. 读后写（WAR）：**本应先读后写**；MIPS流水线在ID段完成所有的读操作，在WB段完成所有的写操作，因此**不会发生WAR冲突**

4. 数据冲突解决方案：

   1. 旁路（定向）技术

      <img src="image\coo33.png" alt="image-20220830181444587" style="zoom: 67%;" />

      以EXE段数据冲突为例，检测点：当前指令的ID/EX段和上一条指令的EX/MEM段

      1. EX/MEM.RegWrite：上一条指令要写寄存器

      2. EX/MEM.RegisterRd != 0：上一条指令的目的寄存器编号不为0

      3. EX/MEM.RegisterRd = ID/EX.RegisterReadRs (Rt)：上一条指令的写入寄存器和当前指令的源寄存器相同

   2. 暂停流水线（对于某些冲突，不得不暂停流水线）

      <img src="image\coo34.png" alt="image-20220830182045057" style="zoom:67%;" />

      检测点：ID段

      1. ID/EX.MemRead：上一条指令为Load指令（根据MemRead信号判断）
      2. ID/EX.RegisterRt == IF/ID.RegisterRs OR ID/EX.RegisterRt == IF/ID.RegisterRd：上一条指令的写入寄存器和当前指令的某一源寄存器相同

      <img src="image\coo35.png" alt="image-20220830182219460" style="zoom:67%;" />

   3. 静态调度（编译器调度）：尽量通过分离有冲突问题的指令使它们**不会导致冲突**

      <img src="image\coo36.png" alt="image-20220830182853569" style="zoom:67%;" />

   4. 动态调度：硬件动态调整指令执行顺序，**在冲突出现时尽量避免暂停（不能真正消除冲突）**

      方法：指令顺序发射——乱序执行——指令乱序流出

      问题：异常处理不精确——在某条指令产生异常时，后面的指令可能已经执行完成了

### 控制冲突和异常

1. 控制冲突：**转移类指令**造成流水线断流，引起程序执行方向的改变，为**全局冲突**

   <img src="image\coo37.png" alt="image-20220830184702886" style="zoom: 50%;" />

2. 控制冲突解决方案：

   1. 暂停流水线

   2. 预测分支不成功：继续执行下一条指令；预测错误要清除影响

   3. 预测分支成功：计算出分支的目标地址，随后在分支目标地址处取指令执行；预测错误要清除影响

   4. 动态预测：硬件根据上次分支的结果进行预测

      <img src="image\coo38.png" alt="image-20220830185157834" style="zoom:50%;" />

   5. 编译器处理：延迟槽

      * 后续指令放在分支延迟槽中，无论分支转移是否成功，这些指令都要被流水执行

      * 选择哪些指令放在延迟槽中呢？

        <img src="image\coo39.png" alt="image-20220830190017304" style="zoom:67%;" />

        | 调度策略     | 所受限制                                                     | 对流水线性能改善的影响                           |
        | ------------ | ------------------------------------------------------------ | ------------------------------------------------ |
        | 来自分支前面 | 分支必须不依赖于被调度的指令                                 | 总是可以提高性能                                 |
        | 来自目标地址 | 如果分支转移失败，必须保证被调度的指令对程序的执行没有影响，可能还需要复制被调度的指令 | 分支转移成功时提高，但复制指令可能会加大程序空间 |
        | 来自延迟槽后 | 如果分支转移成功，必须保证被调度的指令对程序的执行没有影响   | 分支转移失败时提高                               |

3. 异常

   <img src="image\coo40.png" alt="image-20220830190457728" style="zoom:50%;" />

4. 异常处理

   <img src="image\coo41.png" alt="image-20220830190601776" style="zoom:50%;" />

## 第三单元

### 层次存储器系统 动态存储器

1. 分类

   1. 随机访问存储器（RAM）：访问时间与存放位置无关

      半导体存储器

   2. 顺序访问存储器（SRAM）：按照存放位置依次访问

      磁带存储器

   3. 直接访问存储器（DRAM）：随机+顺序

      磁盘存储器

   4. 关联访问存储器（CAM）：根据内容访问

      Cache、TLB

2. 局部性原理

   1. 时间局部性
   2. 空间局部性
   3. 访问顺序上：指令顺序执行比转移执行的可能性大

3. 层级之间应满足的原则

   1. 一致性原则：内外一致
   2. 包含性原则：内为外的复制品

4. 地址总线：20位地址——访问1MB空间；32位地址——4G

### 静态存储器及高速缓冲存储器

1. <img src="image\coo42.png" alt="image-20220831172510750" style="zoom: 50%;" />

2. 高速缓冲存储器Cache
   1. 定义：设置于主存与CPU之间，使用静态存储器，缓存CPU频繁访问的信息
   2. 特点：
      1. 高速：与CPU运行速度基本匹配
      2. 透明：完全硬件管理，对程序员透明

3. Cache主要参数

   <img src="image\coo43.png" alt="image-20220831174943214" style="zoom:50%;" />

### Cache

1. Cache地址映射方式

   |            | 特点                                                         | 缺点                                             |
   | ---------- | ------------------------------------------------------------ | ------------------------------------------------ |
   | 全相联     | 主存的字块可以和Cache的任何字块对应，利用率高，方式灵活      | 使用成本太高                                     |
   | 直接映射   | 主存的字块只可以和固定的Cache字块对应，方式直接，利用率低。标志位较短，比较电路的成本低 | 利用率低，命中率低，效率较低                     |
   | 多路组相联 | 前两种方式的综合方案。先通过直接映射方法确定组，再在组内通过全相联方式确定行 | 集中了两个方式的优点。成本也不太高。是常用的方式 |

   1. 直接映射：每个主存块映射到cache的固定行中（模映射：cache行号=主存块号 mod cache行数）

      * （索引：说明这一块在cache对应的第几行）

        <img src="image\coo46.png" alt="image-20220831182045201" style="zoom:50%;" />

      * 主存4GB：地址空间32位

        块大小4B：块内地址2位

        4KB/4B=$2^{10}$行，故需10位索引位（主存块在Cache中的位置=主存块号%cache总块数，这也就意味着主存块号的末尾10位直接反映在了cache的位置中，标记位就不需要保存这10位数据了）

        剩下来的作为标记，20位

        <img src="image\coo47.png" alt="image-20220831182158314" style="zoom:50%;" />

      * 利用率低，命中率第，效率低

        <img src="image\coo48.png" alt="image-20220901102153461" style="zoom:50%;" />

      * 标志位较短，比较电路的成本低：主存空间$2^m$块，cache中字块$2^c$块，则标志位只需要m-c位，且仅需要比较1次

   2. 全相联：每个主存块映射到cache的任意行中

      * （标记：主存地址的块号。CPU在cache中找块时，依次比较标记，从而找出需要的地址）

      <img src="image\coo44.png" alt="image-20220831181547742" style="zoom:50%;" />

      * 主存4GB：地址空间32位

        块大小4B：块内地址2位，块号30位

        全相联标记位数和块号位数相等，也要30位

        <img src="image\coo45.png" alt="image-20220831181744643" style="zoom:50%;" />

      * 利用率高，方式灵活
      * 标志位较长，比较电路的成本太高：n位的主存地址，块内地址为b位，cache有m块，则需要m个比较电路，标志位需要n-b位

   3. 两路组相联：每个主存块映射到cache的固定组的任意行中

      * 先通过直接映射确定组，再在组内通过全相联方式确定行

        <img src="image\coo49.png" alt="image-20220901102535296" style="zoom:50%;" />

        <img src="image\coo50.png" alt="image-20220901102737632" style="zoom:50%;" />

   4. 四路组相联

      * 主存地址空间32位

        块内空间2位

        主存块号共32-2=30位

        索引位：4KB/4B=$2^{10}$个cache块，分4路，即每路$2^8$个cache块，需要8位索引位

        剩下来的即标志位30-8=22位

        <img src="image\coo51.png" alt="image-20220901102929749" style="zoom:50%;" />

   5. 一路组向量（直接映射）$\rightarrow$ 组相联 $\rightarrow$ 八路组向量（全相联）

      <img src="image\coo52.png" alt="image-20220901103349588" style="zoom:67%;" />

2. 一致性保证（王道：写回法/全写法；写分配法/非写分配法）

   1. 写直达

      * 强一致性保证，效率低
      * 在Cache中命中
        * 同时修改Cache和对应主存中的内容
      * 未在Cache中命中
        * 写分配
        * 非写分配：暂时不装入（因为有可能不会继续写了）

   2. 拖后写

      * 弱一致性保证，替换时再写主存
        * 主动替换
        * 被动替换
      * 通过监听总线上的访问操作来实现
      * 实现复杂，效率较高

   3. 提高存储访问的性能：平均访问时间=命中时间×命中率+失效损失×失效率

      1. 提高命中率
      2. 缩短缺失访问时间
      3. 提高Cache本身的速度

   4. Cache缺失的原因

      1. 必然缺失：开机、进程切换、首次访问数据块
         * 预取
      2. 容量缺失：活动数据集超出了Cache的大小
         * 增加Cache容量
      3. 冲突缺失：多个内存块映射到了同一个Cache块/某一Cache组块已满（虽然其他组可能仍有空闲Cache块）
         * 增加Cache容量（直接映射）/增加相联的组数（组相联）
      4. 无效缺失：其他进程修改了主存数据

   5. 影响命中率的因素

      1. Cache容量

      2. Cache块大小
         * 块较大时，缺失率较低
         * 可以更好地利用空间局部性
         * 但需要更长时间来装入数据块
         * 相对Cache总容量而言太大的话（Cache块数太少），命中率反而会降低，且会增加缺失损失
         
      3. 地址映射方式

      4. 替换算法
         * 全相联/多路组相联失效时，需要选择替换出哪一个Cache块
         * 最近最少使用LRU/先进先出FIFO/随机替换RAND
         
      5. 多级Cache
         1. 增加Cache的层次
         
         2. 分解为指令Cache和数据Cache
         
         3. 各级Cache之间：全写法+非写分配法
         
            Cache和主存之间：写回法+写分配法

   6. Cache接入系统的体系结构

      1. 侧接法：和入出设备相似

         * 不利于降低总线的占用率

      2. 隔断法：将总线分为两段，Cache居于中间

         <img src="image\coo53.png" alt="image-20220901105432599" style="zoom:50%;" />

         * 提供总线利用率，支持总线并发

### 虚拟存储器

1. <img src="image\coo54.png" alt="image-20220901110158669" style="zoom:50%;" />

2. 用途

   1. 更大的逻辑地址空间
      * 通过页表将虚地址转换成实地址
   2. 实现内存共享
      * 每个进程都有独立的逻辑地址空间
      * 通过逻辑地址和物理地址的转换机制实现物理地址内存的共享
   3. 实现内存保护
      * 页表中存放访问权限
      * 通过硬件来保证权限（操作系统的“陷阱”操作）

3. | 虚拟存储器               | Cache                       |
   | ------------------------ | --------------------------- |
   | 克服存储容量的不足       | 解决主存储器和CPU性能的差距 |
   | 获得对主存储器管理的便利 | 获得最小粒度的访问          |
   | 由操作系统管理           | 由硬件实现                  |

4. 段式、页式、段页式（见操作系统笔记）

5. 转换旁路缓冲（TLB）

   <img src="image\coo55.png" alt="image-20220901113411483" style="zoom:50%;" />

   <img src="image\coo56.png" alt="image-20220901113451479" style="zoom:50%;" />

### 磁表面存储设备

1. 硬磁盘内部结构

   <img src="image\coo57.png" alt="image-20220901114331192" style="zoom:50%;" />

   <img src="image\coo58.png" alt="image-20220901114444115" style="zoom:50%;" />

2. 硬磁盘访问时间

   <img src="image\coo59.png" alt="image-20220901114708400" style="zoom:50%;" />

3. RAID：廉价磁盘冗余阵列

   | RAID  | 实现方式                                                     | 评价                                                         |
   | ----- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | RAID0 | **条带化**：以交叉循环的方式将数据**写到连续的带**中         | 1. 适合数据请求量比较大的情况；2. 没有冗余，可靠性差，不算真正的RAID |
   | RAID1 | **复制了所有的磁盘**，每次写都进行两次，每次读可以读取任意一个备份，把负载均衡分布到不同的驱动器上 | 1. 冗余备份，可靠性高；2. 写性能不高，但读性能提高了两倍；3. 成本较高 |
   | RAID2 | 将字节分解成一对4位的半字节，对**每个半字节**加上三位海明码**形成7位字**，然后将7个驱动器的磁头和旋转同步，从而实现将整个海明码字写在7个驱动器上，每个驱动器一位 | 1. 驱动器必须足够多；2. 驱动器需要同步旋转；3. 需要多个控制器 |
   | RAID3 | RAID2的简化版本，**每个字只计算一个校验位**，写到一个校验驱动器上 | 1. 驱动器需要同步旋转；2. 对整个磁盘崩溃的错误，能够进行恢复 |
   | RAID4 | RAID0的改进版本，将**对带的校验写在额外的驱动器上**          | 1. 不对字进行校验，也不需要驱动器同步；2. 可以防止整块盘崩溃，但对盘上部分字节数据出错的纠错性能相当差；3. 校验盘负载沉重 |
   | RAID5 | RAID4的改进版本，将**校验位循环均匀分布**到所有的驱动器上    | 1. 磁盘崩溃的话，修复将会很复杂                              |
   | RAID6 | 二维校验                                                     | 1. 可以应对两块硬盘出错的情况                                |

   RAID0：<img src="image\coo60.png" alt="image-20220901175446178" style="zoom: 50%;" />

   RAID1：<img src="image\coo61.png" alt="image-20220901180027087" style="zoom:50%;" />

   RAID2：<img src="image\coo62.png" alt="image-20220901180525387" style="zoom:50%;" />

   RAID3：<img src="image\coo63.png" alt="image-20220901180745080" style="zoom:50%;" />

   RAID4：<img src="image\coo64.png" alt="image-20220901181241372" style="zoom:50%;" />

   RAID5：<img src="image\coo65.png" alt="image-20220901181430531" style="zoom:50%;" />

   RAID6：<img src="image\coo66.png" alt="image-20220901181556200" style="zoom:50%;" />

### MIPS异常及中断

## 第四单元

### 输入/输出系统概述 输入/输出方式

1. 输入输出方式

   1. 程序直接控制
      * 成本低，效率低，严重占用CPU资源
   2. 程序中断
      * 外部设备发起请求，CPU暂停正在执行的程序进行响应
      * 提高CPU的效率
      * 可以同时管理多个外部设备
   3. 直接存储访问（DMA）
   4. 通道
   5. 外围处理机

2. 中断

   1. 中断源：外中断（IO设备等）、异常（内中断）（处理器硬件故障、程序“出错”、Trap）、中断触发器、中断状态寄存器
   2. 禁止中断与中断屏蔽：中断允许触发器、有选择封锁
   3. <img src="image\coo67.png" alt="image-20220902175154721" style="zoom: 67%;" />
   4. 中断控制方式特点
      1. 适用于传输速度不高，传输量不大的场合
      2. 对CPU干扰较大

3. 直接存储访问（DMA）

   1. <img src="image\coo68.png" alt="image-20220902175726715" style="zoom: 50%;" />

   2. <img src="image\coo69.png" alt="image-20220902180310227" style="zoom:67%;" />
   3. 问题
      1. DMA若采用实地址，则虚拟地址，而实地址不连续；DMA若采用虚地址，则需在DMA进行虚实地址转换
      2. Cache一致性
         * 主存中的数据可能不是最新的
         * 采用直接写可能会带来性能的降低
         * DMA查询Cache，会降低性能
         * 可以直接设计硬件控制
   4. 特点
      1. 与设备一对一服务（多DMA控制器同时工作可能发生冲突）
      2. 对CPU打扰适中
      3. 无法适用大量高速设备的管理

4. 通道控制

   1. 能执行有限IO指令集合（通道命令）的IO处理机
   2. 一对多的连接关系
   3. 适应不同速度、不同种类的外部设备，可并行工作
   4. 分类：字节多路通道、选择通道、数组多路通道

5. 外围处理机

   1. 通用计算机，独立输入输出（通道型处理机：共享内存）
   2. 使用通道方式与主机交互

### 总线

1. 总线是**连接计算机多个子系统**的**共享的信息通道**

2. 总线类型

   <img src="image\coo70.png" alt="image-20220902184745947" style="zoom: 50%;" />

3. 总线组成

   <img src="image\coo71.png" alt="image-20220902185042886" style="zoom:50%;" />

4. 主设备：发起总线事务（包括发起命令、传输数据）

   从设备：响应主设备请求

   总线通信协议：定义总线传输中的事件顺序和时序要求

   异步总线传输：控制信号（请求、应答）作为总控信号

   同步总线传输：使用共同的时钟信号

5. 总线仲裁：多个设备需要使用总线的时候，安排总线的使用顺序

   1. 集中仲裁
      1. 菊链仲裁：所有设备共用一个总线请求信号
         1. 无法保证公平性
         2. 总线授权信号逐级传递，限制了申请总线的速度
      2. 集中平行仲裁：通过集中的仲裁器进行仲裁
   2. 分布仲裁：通过自我选择进行分布式仲裁
   3. 按优先级仲裁或轮循仲裁

6. 同步和异步总线

   <img src="image\coo72.png" alt="image-20220902190358874" style="zoom:50%;" />

7. 提高总线速度

   1. 增加总线的宽度
   2. 分别设置数据总线和地址总线
   3. 采用成组传送的方式
      * 一个总线事务传送多个数据，直到数据传送完毕才释放总线
      * 代价：复杂度提高，延长后续总线请求等待时间
   4. 多主设备总线提高事务数量
   5. 仲裁重叠：在当前事务时，为下一总线事务进行仲裁
   6. 总线占用：在没有其他主设备请求总线的情况下，某主设备一直占用总线，完成多个总线事务

### 接口电路和外部设备

1. 接口的基本功能

   <img src="image\coo73.png" alt="image-20220902191844107" style="zoom:50%;" />
