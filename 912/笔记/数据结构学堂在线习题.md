# 数据结构-学堂在线习题

## 第一章 绪论

1. 以下哪项不是图灵机的组成要件？

   A 有限长的纸带

   B 有限的字母表

   C 有限种状态

   D 读写头

   答案：A

   解析：作为一个理想计算模型，图灵机的纸带是两端无线延伸的*无限长*纸带。

2. 判断正误：RAM模型与图灵机模型的区别在于图灵机的存储空间无限，而RAM的存储空间有限。

   A 对

   B 错

   答案：B

   解析：RAM模型中*寄存器的总数没有限制*（虽然我们平时使用的计算机无法做到），它与图灵机是等价的。

3. 下列对应关系中错误的是

   A $1^2+2^2+3^2+...+n^2=O(n^3)$

   B $1+2+4+...+2^n=O(2^n)$

   C $\log1+\log2+\log3+...+\log n=O(nlog n)$

   D $1+1/2+1/3+...+1/n=O(n\log n)$

   答案：D

   解析：$1+1/2+1/3+...+1/n=O(\log n)$

4. 判断：经过k轮扫描交换后，起泡排序程序会将问题规模缩减至k。

   A 对

   B 错

   答案：B

   解析：经过k轮扫描交换后，最大的k个元素已经就位，因此问题*规模缩减为n-k*

5. 判断：减而治之的思想是：将问题划分为两个平凡的子问题，分别求解子问题，来得到原问题的解。

   A 对

   B 错

   答案：B

   解析：“划分为两个平凡的子问题”这一描述有误，应当是划分为*一个平凡、一个规模缩减*的两个子问题。所谓“平凡的问题”，是指无需进行复杂运算，可以直接给出结果的问题。例如，“对n个数进行排序”是一个复杂的问题，但当n等于1时，问题便成为了一个平凡的问题，因为序列长度为1，则序列自然是有序的。

6. 直接用定义以递归的方式计算fib(n)的时间复杂度是：

   A $\Theta(n^2)$

   B $O(2^n)$

   C $\Theta(2^n)$

   D $O(n)$

   答案：B

   解析：$T(n)=1+T(n-1)+T(n-2)$，不动点法 $\lambda^2-\lambda-1=0$，是 $\Theta((\dfrac{1+\sqrt{5}}{2})^n)$

7. 用动态规划计算fib(n)的时间、空间复杂度分别为

   A $\Theta(n^2),\,\Theta(n^2)$

   B $\Theta(n^2),\,\Theta(n)$

   C $\Theta(n),\,\Theta(n)$

   D $\Theta(n),\,\Theta(1)$

   答案：D

   解析：*空间上不需要数组*，只要两个数就行

8. 用动态规划求解输入序列长度分别为m,n的LCS问题，时间复杂度为：

   A $\Theta(mn)$

   B $\Theta(n\log_2⁡m)$

   C $\Theta(m+n)$

   D $\Theta(n^2)$

   答案：A

9. 下列函数渐进增长速度最快的是：

   A $n^{2/3}$

   B $\dfrac{n}{\log_2⁡ n}$

   C $\log_2⁡(\log_2⁡n)$

   D $\log_2^2n$

   答案：B

   解析：对数函数 $\log_2n$ 的渐进增长慢于任何次数的幂函数 $x^\epsilon,\,(\epsilon>0)$，以上几个函数增长速度从小到大是：CDAB

## 第二章 向量

1. `for (int i = 0; i < _size; i++) _elem[i] = oldElem[i];` 和 `memcpy(_elem, oldElem, _size * sizeof(T));`

   A 是，二者是等价的，不会有任何问题。

   B 否，因为二者复制的元素区间范围不同。

   C 否，因为二者的效率不同。

   D 否，因为后者能否达到目的与元素类型T有关。

   答案：D

   解析：当T为非基本类型且有对应的赋值运算符以执行深复制时，前一段代码会*调用赋值运算符*，而后一段只能进行*浅复制*。

2. 在binsearch(e, lo, hi)版本A中，若V[mi] < e，则下一步的查找范围是：

   A V(mi, hi)

   B V[mi, hi]

   C V(mi, hi]

   D V[lo, hi)

   答案：A

   解析：版本A —— 左开，*m*，右*开*

   ​     版本B —— 左开，右*闭*

   ​     版本C —— 左开，右*开*，结果*--*

3. 对于规模为n的向量，二分查找版本A和B的最优时间复杂度分别为：

   A $\Theta(n^2),\,\Theta(n)$

   B $\Theta(n\log_2n),\,\Theta(n)$

   C $\Theta(\log_2n),\,\Theta(\log_2n)$

   D $\Theta(1),\,\Theta(\log_2n)$

   答案：D

   解析：版本A的最优情况即第一次就命中，只需 $\Theta(1)$ 的时间

4. 对于二分查找版本C，当e<V[mi]不成立时下一步的查找范围是：

   A V[lo, mi)

   B V[mi, hi)

   C V[mi, hi]

   D V(mi, hi)

   答案：D

   解析：此处看似会遗漏V[mi]，其实不然。

5. 对于二分查找版本C，当查找区间的长度缩小为0时，V[lo]是：

   A、max{0≤r<n|V[r]<e}

   B、max{0≤r<n|V[r]≤e}

   C、min{0≤r<n|e<V[r]}

   D、min{0≤r<n|e≤V[r]}

   答案：C

   解析：注意lo - 1才是我们需要的返回值

6. 如果（有序）向量中元素的分布满足独立均匀分布（排序前），插值查找的平均时间复杂度为：

   A $O(n)$

   B $O(\log n)$

   C $O(\log\log n)$

   D $O(1)$

   答案：C

   解析：估算，待查找的宽度 —— $n,\,\sqrt{n},\,\sqrt{\sqrt{n}},\,\ldots$，给数列套一个 $\log$ —— $\log n,\,\dfrac{1}{2}\log n,\,(\dfrac{1}{2})^2\log n,\,\ldots$

7. 在向量V={2, 3, 5, 7, 11, 13, 17, 19, 23}中用插值查找搜索元素7，猜测的轴点是

   答案：1

   解析：$0+(8-0)\times\dfrac{7-2}{23-2}\approx1.9=1$

8. V={11, 23, 19, 7, 17, 5, 3, 13, 2, 29}，对V进行起泡排序，两趟扫描交换后V[8] =

   A 17

   B 19

   C 23

   D 29

   答案：C

   解析：每次扫描交换后原无序部分的最大元素必然就位，故所求答案为整个向量中的次大元素

9. 经改进的起泡排序在什么情况下会提前结束？

   答案：完成的扫描交换趟数 = 实际发生元素交换的扫描交换趟数

   解析：另一种说法是“某趟扫描交换中没有发生元素交换”

10. 对于规模为n的向量，归并排序的最优、最坏时间复杂度分别为：

   A $\Theta(n),\,\Theta(n\log_2n)$

   B $\Theta(n\log_2n),\,\Theta(n\log_2n)$

   C $\Theta(n\log_2n),\,\Theta(n^2)$

   D $\Theta(n),\,\Theta(n^2)$

   答案：B

   解析：$T(n)=2T(n/2)+\Theta(n)$，由主定理，稳定 $\Theta(n\log n)$

## 第三章 列表

1. 下列关于向量和列表的说法错误的是：

   A 向量通常在内存中占据连续的空间，列表则通常不是如此

   B 在有序向量中查找渐进地比在有序列表中查找快

   C 向量归并排序的时间复杂度是 $O(n\log_2⁡(n))$，而列表为 $\Omega(n^2)$

   D 列表删除单个节点渐进地比向量删除单个元素快

   答案：C

2. 一个序列的逆序数 $\tau$ 定义为该序列中的逆序对总数，规模为n的列表中插入排序进行的元素比较总次数为:

   A $O(n+\tau\log_2⁡(\tau))$

   B $O(n+\tau)$

   C $O(n^2+\log_2⁡(\tau))$

   D $O(\tau)$

   答案：B

   解析：将每个逆序对归于其中位置靠后的元素可得出 $O(\tau)$，考虑到每一趟插入有可能要进行一次额外的比较（最后一次），最终结果是 $O(n+\tau)$

3. 长度为 $n$ 的列表，被等分为 $n/k$段，每段长度为 $k$，不同段之间的元素不存在逆序。对该列表进行插入排序的最坏时间复杂度为：

   A $O(n^2)$

   B $O(nk)$

   C $O(n^2/k)$

   D $O(n^2k)$

   答案：B

   解析：每段逆序对至多 $O(k^2)$，共 $n/k$ 段，总共 $O(k^2*n/k)=O(nk)$。对每段的排序实际上可以视为分别进行。在某些库中的排序算法（比如STL中的sort）会先用其它的排序算法达到以上分段的效果，再对整个序列调用插入排序，以期获得较高的实际效率。

## 第四章 栈与队列

1. 以下几个量中相等的是:

   ① 不同的n位二进制数个数

   ② 对小括号所能构成的合法括号匹配个数

   ③ {1, 2 .. n}的不同栈混洗个数

   ④ 含n个运算符的中缀表达式求值过程中运算符栈push操作的次数

   A ①②

   B ②③

   C ③④

   D ②④

   答案：B

   解析：Catalan(n)

## 第五章 树

1. 用父节点+孩子节点的方法存储n个节点的树,需要的空间是:

   A $O(1)$

   B $O(n)$

   C $O(n\lg n)$

   D $O(n^2)$

   答案：B

2. 先序遍历的顺序是:

   A 先自下而上访问左侧链上的节点,再自下而上访问它们的右子树

   B 先自上而下访问左侧链上的节点,再自上而下访问它们的右子树

   C 先自上而下访问左侧链上的节点,再自下而上访问它们的右子树

   D 先自下而上访问左侧链上的节点,再自上而下访问它们的右子树

   答案：C

3. 从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，以下说法中错误的是：

   A 经过的节点都是u的祖先

   B 最坏时间复杂度为O(n)

   C 经过的路径是唯一确定的

   D 每上溯一层，当前节点的深度减小1，而高度增加1

   答案：D

   解析：每上溯一层，深度减小1，但*高度的增加可能大于1*，因为节点的高度由其左、右子树中较高者决定。

## 第六章 图

1. 一笔画问题即要找出：

   A 路径

   B 欧拉路径

   C 哈密尔顿环路

   D 简单环路

   答案：B

2. 任何两个顶点间都有一条（无向）边的图称为完全图，包含n个顶点的完全图用K~n~表示。下列哪个图一定不是平面图？

   A K~2~

   B K~3~

   C K~4~

   D K~5~

   答案：D

   解析：显然其余三个都是平面图。K~5~不是平面图可以用欧拉公式以及平面图中的一个面最多平均对应3/2条边这一事实来证明。

3. 对于用邻接表实现的包含n个顶点e条边的图，BFS的时间复杂度为：

   A $O(n)$

   B $O(n^2)$

   C $O(n+e)$

   D $O(n^2+e)$

   答案：C

4. 对图进行DFS，一下哪种情况意味着该图包含环路

   A 有TREE边

   B 有BACKWARD边

   C 有FORWARD边

   D 有CROSS边

   答案：B

5. G是简单无向图，A为G的邻接矩阵，M为G的关联矩阵，D是对角线上第i个元素为顶点i的度的对角矩阵,它们的关系是：

   A $A=M$

   B $A+D=MM^T$

   C $A+D=M^TM$

   D 没有直接关系

   答案：C

6. G是有向无环图，(u, v)是G中的一条由u指向v的边。对G进行DFS的结果是：

   A dTime(u) > dTime(v)

   B dTime(u) < dTime(v)

   C fTime(u) > fTime(v)

   D fTime(u) < fTime(v)

   答案：C

## 第七章 图应用

1. 对于同一*无向图*，起始于顶点s的DFS尽管可能得到结构不同的DFS树，但*s*在树中的*度数必然固定*。

   答案：正确

   解析：考察双连通分量/关节点。PS. 有向图中，该结论不成立。

## 第八章 二叉搜索树

1. 对BST进行插入操作，对待插入的目标元素e进行查找后，若查找失败，_hot指向的节点为：

   A 待插入的节点

   B e被插入后的父亲

   C e被插入后的左孩子

   D 根节点

   答案：B

2. 当欲删除的节点v在BST中的度为2时，实际被删除的节点为：

   A v在中序遍历下的直接前驱

   B v在先序遍历下的直接后继

   C v的右子树中左侧分支的最后一个节点

   D v的父亲

   答案：C

   解析：即v在中序遍历下的直接后继

   <img src="image\dsa29.png" alt="image-20221017135742633" style="zoom:80%;" />

3. 两个等价的平衡二叉搜索树有相同的：

   A 先序遍历序列

   B 中序遍历序列

   C 后序遍历序列

   D 层次遍历序列

   答案：B

4. 在AVL树中刚插入一个节点后失衡节点个数最多为

   A $O(1)$

   B $O(\lg\lg n)$

   C $O(\lg n)$

   D $O(n)$

   答案：C

   解析：插入/删除失衡 $O(\log n)/O(1)$，重平衡 $O(1)/O(\log n)$

5. 高度为3的AVL树至少包含几个节点？

   答案：$fib(h+3)-1=7$（画图的话，各层 $1+2+3+1$）

6. AVL树中插入节点引发失衡，经旋转调整后重新平衡，此时包含节点g,p,v的子树高度

   A 减小1

   B 不变

   C 增加1

   D 有可能不变也有可能增加1

   答案：B

   解析：故在AVL树中修正插入节点引发的失衡不会出现失衡传播

7. AVL树中删除节点引发失衡，经旋转调整后重新平衡，此时包含节点g,p,v的子树高度

   A 减小1

   B 不变

   C 增加1

   D 有可能不变也有可能减小1

   答案：D

   解析：故在AVL树中修正删除节点引发的失衡有可能出现失衡传播

8. 包含节点{1,2,3,4}的不同二叉搜索树有多少棵？

   答案：14

   解析：Catalan(4)

## 第十章 高级搜索树

1. 按照Tarjan的伸展算法，单次伸展操作的分摊复杂度为：

   A $O(1)$

   B $O(\lg n)$

   C $O(n)$

   D $O(n\lg n)$

   答案：B

2. 双层伸展策略优于逐层伸展策略的关键在于（）

   A zig-zig/zag-zag

   B zig-zag/zag-zig

   C zig-zig/zig-zag

   D 以上均是

   答案：A

   解析：zig-zag/zag-zig操作等效于逐层伸展的操作。双层伸展的关键是实现长序列有效地折叠，而zig-zig/zag-zag可以实现折叠效果

3. 伸展树采用双层伸展策略，即可避免最坏情况的发生（）

   答案：错误

   解析：不能避免最坏情况，但是可以有效控制最坏情况发生的频度

4. 所访问的节点及其父亲都是右孩子，则双层伸展要执行的操作是：

   A zig-zag

   B zag-zig

   C zig-zig

   D zag-zag

   答案：D

   解析：zig顺，zag逆

5. 在任意一颗伸展树中，按节点值的大小以升序依次访问完所有节点，最后树变为一条单链，且仅含左孩子

   答案：正确

   解析：由于是按照升序访问，那么下一次访问必定是当前根节点的直接后继，所以后继将旋转至根节点作为新的根节点，而旧根节点必定变为新根节点的左孩子。遍历完毕后，右孩子必定为空，新树仅存在左孩子。

6. 内存“越来越小”的原因是：

   A 机器上运行的程序越来越多，平均每个程序使用的内存变小

   B 实际应用对存储的需求急剧增

   C 用于制造内存芯片的硅资源消耗殆尽

   D 随着工艺的进步，内存的体积变小，集成度变高

   答案：B

7. 如果说访问一次内存需要1秒，则一次外存访问大概需要：

   A 小时

   B 1天

   C 1月

   D 1年

   答案：B

8. 4阶B树中每个节点的分支数为：

   A 1~4

   B 2~5

   C 2~4

   D 3~5

   答案：C

   解析：节点数1~3，分支数 2~4

9. 在存储了n个元素的4阶B树中查找，*单个节点进行一次*查找的时间复杂度为：

   A $O(1)$

   B $O(\lg n)$

   C $O(n)$

   D $O(n\lg n)$

   答案：A

10. B树查找算法若最终失败，返回值为：

    A None

    B NULL

    C 指向最后一个所查找节点的指针

    D 指向根节点的指针

    答案：B

11. 若B树的阶m=128，则它的高度大致是对应的BBST的：

    A 1/5

    B 1/6

    C 1/7

    D 1/8

    答案：B

    解析：$\left[\dfrac{1}{\log_2m},\,\dfrac{1}{\log_2m-1}\right]=\left[\dfrac{1}{7},\,\dfrac{1}{6}\right]$，这里应该是“所有可能的B树都至少降到 $\dfrac{1}{6}$”

12. B树高度的增加一定伴随着：

    A 每个节点所存放的关键码数量增加

    B 每个节点所存放的关键码数量减少

    C 分裂到根

    D 分裂到叶

    答案：C

13. B树高度的减少只会发生于

    A 根节点的两个孩子合并 

    B 根节点被删除

    C 根节点发生旋转

    D 根节点有多个关键码

    答案：A

    解析：根节点被删除的时候，根据删除算法，根节点首先是需要和其中序遍历的后继结点交换，删除的结点实际上其后继结点(succ)，而删除这个结点并不一定会导致下溢传播，故也并不可能一定导致B树高度减少

14. 如果在不发生上溢和下溢的情况下，那么单次删除和插入操作的时间花费大致相同

    答案：错误

    解析：插入操作的时间花费主要来自于search(e)，因为B-树中，跨节点访问的时间花费（IO操作）远大于在节点内部的顺序访问。然而，在删除操作中，时间花费来自search(e)以及查找后继节点所花的时间，后继的查找还要继续往下进行跨节点访问。因此*删除操作更费时间*。当然，在最坏情况下，两者花费相等。

15. 所有AVL树可以染成红黑树，所有红黑树都是AVL树

    答案：前半句正确，只需将高度为偶数的非根节点，染为红色，否则染为黑色。因为AVL的对于左右子树高度的平衡要求比红黑树更加严格，因此有些红黑树可能不满足AVL的要求

16. 当叔父节点u为红色时，修正双红缺陷导致的红黑树*拓扑结构*的变化为：

    A 没有变化

    B 有变化，但是不超过O(1)

    C 有变化，但是不超过O(lgn)

    D 有变化，但是不超过O(n)

    答案：A

    解析：黑————旋转+染色；红————不用旋转，染色可能上溢

17. 伸展树插入操作的分摊复杂度比AVL树大

    答案：错误

    解析：单次更大，但分摊都是 $O(\log n)$

18. 以下关于红黑树的说法，错误的是：

    A 含n个节点的红黑树，其黑高度为O(lgn)，但是总的高度却未必是O(lgn)

    B 从红黑树的任一外部节点上溯到根节点，沿途不可能经过连续两个红色节点

    C 红黑树的黑高度一定不小于总高度的一半

    D 红黑树中的黑色节点u有黑色左孩子x和黑色右孩子y,则x与y的黑高度一定相等

    答案：A

19. 在红黑树中直接按照常规的BST删除节点算法删除一个节点，关于红黑树结构的四条性质是否有可能被破坏？

    1. 树根必为黑色

       可能

    2. 外部节点必均为黑色

       不可能

    3. 红色节点的孩子必为黑

       可能

    4. 从根到外部节点的不同路径途中黑色节点数目相等

       可能

## 第十一章 词典

1. N个待排序元素的取值范围是[1, M]，计数排序的时间复杂度为：

   A $O(N\lg N)$

   B $O(N)$

   C $O(M)$

   D $O(M+N)$

   答案：D

2. S为所有可能词条的空间，A为所有可用地址的空间（|A| < |S|），h是散列函数，则：

   A h从S映射到A，一定是满射

   B 从S映射到A，不可能是单射

   C h从A映射到S，不可能是满射

   D h从A映射到S，一定是单射

   答案：B

3. 对[0, 11)中的整数{ 10, 4, 2, 9, 3, 1, 2, 2, 4, 9, 8, 5, 9, 10, 7, 6, 9 }用计数排序，得到的accum[]表为：

   A {0, 1, 3, 1, 2, 1, 1, 1, 1, 4, 2}

   B {10, 4, 2, 9, 3, 1, 2, 2, 4, 9, 8, 5, 9, 10, 7, 6, 9}

   C {0, 1, 4, 5, 7, 8, 9, 10, 11, 15, 17}

   D {0, 1, 4, 7, 9, 12, 13, 14, 15, 16, 17}

   答案：C

   解析：count[]表是A，accum[]表是accumulate后的

## 第十二章 优先级队列

1. 完全二叉堆在物理上是向量，其所存储的元素次序是

   A 完全二叉树的先序遍历次序

   B 完全二叉树的中序遍历次序

   C 完全二叉树的后序遍历次序

   D 完全二叉树的层次遍历次序

   答案：D

2. 堆排序在流程上类似于以前学过的哪种排序？

   A 选择排序

   B 插入排序

   C 冒泡排序

   D 归并排序

   答案：A

   解析：不断选出最大的

## 第十三章 串

1. 给定一个进行串匹配的算法，如何衡量它的效率？

   A 随机生成大量的文本串T和模式串P作为输入，通过实验的方法进行测量

   B 认为所有不同文本串T和模式串P出现的概率是相等的，依此计算时间复杂度的期望

   C 对于成功匹配和失败匹配两种情况分别讨论其时间复杂度

   D 选取固定的文本串T，随机选取模式串P，计算时间复杂度的期望

   答案：C

2. KMP算法的查询表为next[]，模式串为P，若P[0,j)与文本串匹配，而在P[j]处失配，则：

   A P[0, next[j]) = P[j - next[j], j)

   B P[0, next[j]+1) = P[j - next[j], j+1)

   C P[0, next[j] - 1) = P[j - next[j], j)

   D P[0, next[j]) = P[j - next[j] - 1, j)

   答案：A

3. 令 A = {t | P[0, t) = P[j - t, j)} ，即A是所有使得P[0,j)的前缀与后缀相等的长度t，如何计算next[j]？

   A next[j] = min A

   B next[j] = max A

   C next[j] = |A| (the cardinality of A A中的元素个数)

   D next[j] = max A - |A|

   答案：B

4. 在通过next[j]计算next[j+1]的递推过程中next[j+1] == next[j] + 1当且仅当：

   A j = 0

   B P[j] = P[next[j] - 1]

   C T[j] = P[j]

   D P[j] = P[next[j]]

   答案：D

## 第十四章 排序

1. 从规模为n的向量中选取中位数，quickselect算法的最坏时间复杂度是：

   A $O(\log n)$

   B $O(n)$

   C $O(n\log n)$

   D $O(n^2)$

   答案：D

   解析：尽管内循环仅需 $\mathcal{O}(hi-lo+1)$ 时间，但是很遗憾，外循环的次数却无法有效控制，与快速排序算法一样，最坏情况下外循环需执行 $\Omega(n)$ 次，总体运行时间为 $\mathcal{O}(n^2)$

2. 希尔排序为什么使用插入排序：

   A 插入排序渐进的效率高

   B 插入排序简单，容易实现

   C 插入排序对输入序列的有序程度敏感

   D 插入排序是稳定的

   答案：C

3. 查阅C++ STL的参考资料，会发现其中有一个stable_sort()函数，顾名思义，推测（或查阅）它通常是用什么算法实现的：

   A 快速排序

   B 归并排序

   C 堆排序

   D 希尔排序

   答案：B

4. 为了防止快速排序因为总是选取到不平衡的轴点而变得低效，除了"三者取中"之外还可以用其它方法。查阅快速排序的一个变种——内省排序(Introsort)是如何解决这个问题的，它将\_\_\__\_与快速排序结合（它是STL中sort()函数的主要实现方法）

   A 归并排序

   B 堆排序

   C 希尔排序

   D 冒泡排序

   答案：B

5. 对序列A[0, n)用快速排序算法进行排序，u和v是该序列中的两个元素。在排序过程中，u和v发生过比较，当且仅当：（假定所有元素互异）

   A u < v

   B u在某次被选取为轴点

   C 对于所有介于u和v之间的元素（包括u和v本身），它们之中第一个被选为轴点的是u或者v

   D 所有比u和v都小的元素都始终没有被选为轴点

   答案：C

6. 快速排序算法选取轴点时可以采取不同的策略，本题试图用实例说明“三者取中”的策略比随机选取的策略倾向于得到更平衡的轴点

   设待排序序列的长度n很大，若轴点的选取使得分割后长/短子序列的长度比大于9:1，则称为不平衡

   针对不同的轴点选取策略，估计其发生不平衡的概率(请填十进制小数)：

   从n个元素中等概率随机选取一个作为轴点：（）

   从n个元素中等概率选取三个元素，以它们的中间元素作为轴点：（）

   答案：0.2	0.056

   解析：$0.2=0.1+0.1$

   ​     $0.056=2\times(0.1^3+\C_3^2\cdot0.1^2\cdot0.9)$

7. 我们在本节中已经得到了最坏时间复杂度为O(n)的中位数选取算法，若把它用于快速排序的轴点选取，得到的快速排序最坏时间复杂度为\__\____

   A $O(n)$

   B $O(n\lg\lg n)$

   C $O(n\lg n)$

   D $O(n^2)$

   答案：C

   实际上（）

   A 该方法可行

   B 不可行，因为中位数选取算法不能用于快速排序

   C 不可行，因为线性时间的中位数选取算法实际效率非常低

   D 不可行，因为空间复杂度太高

   答案：C

   